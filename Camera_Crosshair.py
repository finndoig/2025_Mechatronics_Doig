# This is the vision library OpenCV
import cv2
# This is a library for mathematical functions for python (used later)
import numpy as np
# This is a library to get access to time-related functionalities
import time
# This is the Aruco library from OpenCV
import cv2.aruco as aruco 
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s')

def CheckForNewCharacter(slit_frame, char_arr1, char_arr2, char_arr3, char_arr4):
    """Check which character has the most pixels in view"""
    character_matches = {}
    
    for char_idx, char_arr in enumerate([char_arr1, char_arr2, char_arr3, char_arr4], 1):
        lower = upper = None
        try:
            nums = char_arr.astype(np.int32).flatten()
            if nums.size == 6:
                lower = np.array(nums[:3], dtype=np.uint8)
                upper = np.array(nums[3:6], dtype=np.uint8)
            elif nums.size == 3:
                tol = np.array([20, 20, 20], dtype=np.int32)
                center = nums[:3]
                lower = np.clip(center - tol, 0, 255).astype(np.uint8)
                upper = np.clip(center + tol, 0, 255).astype(np.uint8)
        except Exception:
            lower = upper = None
        
        if lower is not None and upper is not None:
            try:
                rgb_slit = cv2.cvtColor(slit_frame, cv2.COLOR_BGR2RGB)
            except Exception:
                rgb_slit = slit_frame.copy()
            
            mask = cv2.inRange(rgb_slit, lower, upper)
            pixel_count = np.sum(mask > 0)
            character_matches[char_idx] = pixel_count
    
    best_char = max(character_matches, key=character_matches.get) if character_matches else None
    best_count = character_matches.get(best_char, 0) if best_char else 0
    
    return best_char if best_count > 0 else None


Camera=np.load('Calibration.npz') #Load the camera calibration values 
CM=Camera['CM'] #camera matrix 
dist_coef=Camera['dist_coef']# distortion coefficients from the camera 

# load CharacterColours array
from CharacterColours import get_characters

chars = get_characters()
print(chars)   # -> ['Character1', 'Character2', 'Character3', 'Character4']
Character1 = chars[0]
Character2 = chars[1]
Character3 = chars[2]
Character4 = chars[3]

# Select the first camera (0) that is connected to the machine
# in Laptops should be the build-in camera
cap = cv2.VideoCapture(1)
 
# Set the width and heigth of the camera to 1920x1080
cap.set(3,800)
cap.set(4,800)

#Create frame and slit opencv named windows
cv2.namedWindow("frame-image", cv2.WINDOW_AUTOSIZE)
#cv2.namedWindow("slit-image", cv2.WINDOW_AUTOSIZE)

#Position the windows ontop of eachother
cv2.moveWindow("frame-image",0,100)
#cv2.moveWindow("slit-image",400,100)

# Create new variables for character count, lost sight timer and in sight boolean
Character_Count = 8 # how many characters are yet to be seen
LostSightTimer = 0 # timer to track how long since character was last seen
InSight = 0 # boolean to track if character is currently in sight
TargetNumber = 1 # which character number is the current target

# Execute this continuously
while(Character_Count > 0):
    
    mask = None  # Initialize mask for each loop

    # Start the performance clock
    start = time.perf_counter()
    
    # Capture current frame from the camera
    ret, frame = cap.read()

    # --- central slit extraction ---
    # Change this value to control how many pixels wide the slit is
    SLIT_Height = 3  # pixels (odd number keeps perfect centering)

    # image dimensions
    w, h = frame.shape[:2]
    cy = h // 2
    half = SLIT_Height // 2
    # y0 = max(cy - half, 0)
    # y1 = min(cy + half + (SLIT_Height % 2), h)
    y0 = cy - half
    y1 = cy + half

    # extract a thin vertical slit centered horizontally
    slit_frame = frame[:, y0:y1]

    # Draw a small crosshair at the centre of the frame for the display
    # Keep processing on the original `frame`, draw on a copy used for display only
    display = frame.copy()
    # crosshair parameters (pixels)
    CROSSHAIR_HALF = 15  # half-length of each arm
    CROSSHAIR_COLOR = (0, 255, 0)  # BGR green
    CROSSHAIR_THICK = 2

    # compute correct center coordinates (x=cols, y=rows)
    rows, cols = frame.shape[:2]
    cx = cols // 2
    cy = rows // 2

    # horizontal arm
    cv2.line(display, (cx - CROSSHAIR_HALF, cy), (cx + CROSSHAIR_HALF, cy), CROSSHAIR_COLOR, CROSSHAIR_THICK)
    # vertical arm
    cv2.line(display, (cx, cy - CROSSHAIR_HALF), (cx, cy + CROSSHAIR_HALF), CROSSHAIR_COLOR, CROSSHAIR_THICK)

    # Display the frame with crosshair and the slit
    cv2.imshow('frame-image', display)
    #cv2.imshow('slit-image', slit_frame)

    # Stop the performance counter
    end = time.perf_counter()

    # these lines were initally generated by ChatGPT based on the CharacterColours.py structure
    # check whether any pixel in the slit matches Character1 color range and tint the slit red if so
    char_arr1 = np.asarray(Character1)
    char_arr2 = np.asarray(Character2)
    char_arr3 = np.asarray(Character3)
    char_arr4 = np.asarray(Character4)

    # Check for new character if none currently in sight
    if InSight == 0:
        detected_char = CheckForNewCharacter(slit_frame, char_arr1, char_arr2, char_arr3, char_arr4)
        if detected_char is not None:
            InSight = detected_char

    # Handle character currently in sight if there is one
    if InSight > 0:
        # loop through characters to find the one currently in sight
        for char_idx, char_arr in enumerate([char_arr1, char_arr2, char_arr3, char_arr4], 1):
            if char_idx != InSight:
                continue
            else:
                # if this is the character currently in sight, check to see if still visible
                lower = upper = None
                try:
                    nums = char_arr.astype(np.int32).flatten()
                    if nums.size == 6:
                        lower = np.array(nums[:3], dtype=np.uint8)
                        upper = np.array(nums[3:6], dtype=np.uint8)
                    elif nums.size == 3:
                        tol = np.array([20, 20, 20], dtype=np.int32)
                        center = nums[:3]
                        lower = np.clip(center - tol, 0, 255).astype(np.uint8)
                        upper = np.clip(center + tol, 0, 255).astype(np.uint8)
                except Exception:
                    lower = upper = None
                if lower is not None and upper is not None:
                    try:
                        rgb_slit = cv2.cvtColor(slit_frame, cv2.COLOR_BGR2RGB)
                    except Exception:
                        rgb_slit = slit_frame.copy()
                    mask = cv2.inRange(rgb_slit, lower, upper)
                    
                # if character in sight is our targert character, log sighting and fire laser
                if InSight == TargetNumber:
                    logging.info("Target Character %d sighted!", TargetNumber)
                    if np.any(mask):
                        # Paint the matched pixels red onto the display frame (not just the slit)
                        
                        # Overlay red pixels into the corresponding slice of the display
                        ds_slice = display[:, y0:y1].copy()
                        ds_slice[mask > 0] = (0, 0, 255)  # BGR red
                        display[:, y0:y1] = ds_slice

                        # Redraw the crosshair in red on the display
                        RED = (0, 0, 255)
                        cv2.line(display, (cx - CROSSHAIR_HALF, cy), (cx + CROSSHAIR_HALF, cy), RED, CROSSHAIR_THICK)
                        cv2.line(display, (cx, cy - CROSSHAIR_HALF), (cx, cy + CROSSHAIR_HALF), RED, CROSSHAIR_THICK)

                        # Update the display window
                        cv2.imshow('frame-image', display)

                        # (optional) also show the slit with red pixels
                        #slit_copy = slit_frame.copy()
                        #slit_copy[mask > 0] = (0, 0, 255)
                        #cv2.imshow('slit-image', slit_copy)
                else:
                    logging.info("Non-target Character %d sighted.", InSight)  
                    if np.any(mask):
                        # Paint the matched pixels blue onto the display frame
                        ds_slice = display[:, y0:y1].copy()
                        ds_slice[mask > 0] = (255, 0, 0)  # BGR blue
                        display[:, y0:y1] = ds_slice

                        # Redraw the crosshair in blue on the display
                        BLUE = (255, 0, 0)
                        cv2.line(display, (cx - CROSSHAIR_HALF, cy), (cx + CROSSHAIR_HALF, cy), BLUE, CROSSHAIR_THICK)
                        cv2.line(display, (cx, cy - CROSSHAIR_HALF), (cx, cy + CROSSHAIR_HALF), BLUE, CROSSHAIR_THICK)

                        # Update the display window
                        cv2.imshow('frame-image', display)



    # Handle character sighting and lost sight timer. If character hasnt been seen for over 10 loops, decrease character count
    if InSight > 0 and np.any(mask) == False:
        LostSightTimer += 1
        if LostSightTimer > 10: # if character has been out of sight for over 10 loops
            LostSightTimer = 0
            InSight = 0 # reset InSight to nothing in sight value
            Character_Count = Character_Count - 1 # decrease character count but not below 0
            logging.info("Character lost! Characters left: %d", Character_Count)



    # If the button q is pressed in one of the windows 
    if cv2.waitKey(20) & 0xFF == ord('q'):
        # Exit the While loop
        break
    

# When everything done, release the capture
cap.release()
# close all windows
cv2.destroyAllWindows()
# exit the kernel
exit(0)


